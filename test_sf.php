<?php

///////////////////////////////////////////////////////////谁是小偷算/////////////////////////////////////////////////////
//谁是小偷算法? a , b, c, d 编号分别为 1, 2, 3, 4 结果输出为 2, c是小偷 
// for( $i = 1; $i <= 4; $i++ )
// {
//     $dis_a = ($i != 1) ? 1 : 0;
//     $dis_b = ($i == 3) ? 1 : 0;
//     $dis_c = ($i == 4) ? 1 : 0;
//     $dis_d = ($i != $dis_c) ? 1 : 0;
//     if ( $dis_a + $dis_b + $dis_c + $dis_d == 3 )
//     {
//         // printf("%c 是小偷。",64 + $i);   // %c 字符型。可以把输入的数字按照ASCII码相应转换为对应的字符
//         break;
//     }
// }





//////////////////////////////////////////////////////概率问题C(n, m)//////////////////////////////////////////////////////////

 //$n 必须小于$k; C(n, m) = n * (n-1) * ...* (n-m+1)/m*(m-1)*... * 2 * 1 = n * (n-1) * ... * (m+1)/(n-m)*(n-m-1)*...*2*1;
// function c($n, $k)
// {
//     for($i = 0; $i <= $n; $i++ )
//     {
//         $max = $k < $i ? $k : $i;
//         for($j = 0; $j <= $max; $j++ )
//         {
//             if($i == 0 || $j == 0 || $j == $i){
//                 $data[$i][$j] = 1;  //该条件很重要: $i == 0 || $j == 0 || $j == $i
//             }else{
//                 $data[$i][$j] = $data[$i-1][$j] + $data[$i-1][$j-1];  //递推关系
//             }
//         }
//     }
//     return $data[$n][$k];
// }
// print_r(c(50, 48));





/////////////////////////////////////////////////////////三角数塔问题///////////////////////////////////////////////////////

//三角数塔问题
//思想：自底向上的逐步求解（原因在于，这是一个三角形的矩阵形式，向上收缩，便于求解）。
//首先，我们用数组保存三角形数塔，并设置距离矩阵d[i][j]，用于保存节点(i,j)到最底层的最长距离，从而，d[1][1]即为根节点到最底层的最大路径的距离。

// $a[1][1] = 13;
// $a[2][1] = 11;
// $a[2][2] = 8;
// $a[3][1] = 12;
// $a[3][2] = 7;
// $a[3][3] = 26;
// $a[4][1] = 6;
// $a[4][2] = 14;
// $a[4][3] = 15;
// $a[4][4] = 8;
// $a[5][1] = $b[5][1] = 12;
// $a[5][2] = $b[5][2] = 7;
// $a[5][3] = $b[5][3] = 13;
// $a[5][4] = $b[5][4] = 24;
// $a[5][5] = $b[5][5] = 11;
// $result = triangularTower($a, $b);
// function  triangularTower($a, $b)
// {
//     for( $i = 5; $i >=1; $i--)
//     {
//         for($j = 1; $j < $i; $j++)
//         {
//             $b[$i-1][$j] = max([$a[$i-1][$j] + $b[$i][$j], $b[$i][$j+1] + $a[$i-1][$j]]);
//         }
//     }
//     return $b;
// }
// // echo '<pre>'; print_r($result);   //测试
// echo $result[1][1];





////////////////////////////////////////////////////插入排序算法////////////////////////////////////////////////////////////

//插入排序算法;哨兵位,设置哨兵位是程序设计中常用的技巧之一，常用在线性表的处理过程中，比如查找和移动数据操作
//带哨兵位的插入排序，$ls[0]是哨兵位，数据从$ls[1]开始存放

function  insert_sort(&$ls, $n)  //$n 为数组中最大的那个下标
{
    for ($i = 2; $i <= $n; ++$i)   //一层for循环,一层while循环
    {
        if ($ls[$i] < $ls[$i - 1])
        {
            $ls[0] = $ls[$i]; //i位置的数存入哨兵位，因为i位置会被后面的移动数据操作覆盖
            $j = $i;
            while($ls[$j - 1] > $ls[0])//不用再判断j是否越界，直接判断当前位置的值是否大于哨兵位
            {
                $ls[$j] = $ls[$j - 1];
                $j--;   //关键
            }
            $ls[$j] = $ls[0];   //重要,将哨兵位的值赋值给当前 $j
        }
    }
    return $ls;
}
$a = [1=>1, 2=>3, 3=>5, 4=>2, 5=>4, 6=>10,7=>8];
// $a = [1,3,5,2,4,10,8];
// $result = insert_sort($a, 7);
//冒泡排序
function bubble_sort($a)
{
    $num = count($a);
    for($i = 1; $i < $num; $i++ )
    {
        for($j=1; $j < $num; $j++)
        {
            if($a[$j+1] < $a[$j])
            {
                $temporary = $a[$j+1];
                $a[$j+1] = $a[$j]; 
                $a[$j] = $temporary;
            }
        }
    }
    return $a;
}
// $result = bubble_sort($a);
// var_dump($result);



/////////////////////////////////////////////////////获取绝对地址///////////////////////////////////////////////////////////

// echo dirname(__FILE__) ;  //获取绝对地址,绝对地址查询效率高

/////////////////////////////////////////////////////取余运算///////////////////////////////////////////////////////////

//取余运算基本上还是一个除法运算，如果仅仅是判断奇偶数，判断（number & 1）是否等于 0 是更好的方法。更一般的情况，当取余运算的除数是 2 的 n 次方的时候，用 & 运算符代替取余会更高效。比如当 x=2n 的时候，a % x 的结果与 a & (x - 1) 的结果是等价的。
//计算机没有环形数据存储方式，只能用线性表模拟，类似这样的模拟环形数据结构中，取余运算也常常用于下标计算。比如用数组模拟环形数组的情况，从任意位置开始遍历数组，当到达数组最后一个元素时，需要回绕的数据的第一个元素继续遍历，可以这样处理：

// $pos = 0;  //遍历起始位置
// $element = [1,2,3,4,5];
// $n = count($element);  //const N = $n 是错误的，无法将一个变量赋值给常量。
// for ($i = 0; $i < 10; $i++)
//     {
//         echo $element[$pos] . '<br>';
//         $pos = ($pos + 1) % $n;   //重要，实现环形输出， $i 控制输出的个数
//     }





//////////////////////////////////一重循环遍历二维数组////////////////////////////////////////////////////////////////////

// $cells[0][0] = 1;
// $cells[0][1] = 2;
// $cells[0][2] = 3;
// $cells[1][0] = 4;
// $cells[1][2] = 5;
// $cells[1][1] = 6;
// for($i = 0; $i < 6; $i++)
// {
//     $row = $i % 2;  // 2 为行数
//     $col = $i % 3;  // 3 为列数
//     echo $row . '===' . $col . '<br>';
//     echo  $cells[$row][$col] . '<br>';
// }


//i = row * N + col  //该公式将二维坐标还原为一维坐标，一维坐标是按照行来排序，第一行完了紧接着是第二行。



//////////////////////////////////棋盘（迷宫）类算法方向遍历=====》方向数组////////////////////////////////////////////////////////////////////
// 向左搜索：行坐标 i 不变，列坐标 j-1
// 向上搜索：行坐标 i-1，列坐标不变
// 向右搜索：行坐标 i 不变，列坐标 j+1
// 向下搜索：行坐标 i+1，列坐标不变




//////////////////////////////////单链表??? c++ 代码////////////////////////////////////////////////////////////////////
// 1. “判断单链表是否有环”。 2. “如何一次遍历就找到链表中间位置节点”。 3.“单链表中倒数第 k 个节点”。
// 使用双指针的技巧，第一个问题，设置一个“慢指针”和一个“快指针”，从链表头开始遍历，慢指针一次向后移动一个节点，快指针一次移动两个节点。如果链表没有环，则快指针会先到达最后一个节点（NULL），否则的话，快指针会追上慢指针（相遇）。
//第二个问题同样设置一快一慢两个指针，慢指针一次移动一个节点，快指针一次移动两个节点，当快指针移动到结尾时，慢指针指向的就是中间节点。
//第三个问题也是双指针，其中一个先移动 k 个节点，然后两个指针以相同的速度一起移动，当先移动的指针移动到结尾的时候，后移动的指针指向的就是倒数第 k 个节点。



//////////////////////////////////二分查找////////////////////////////////////////////////////////////////////

//操作的数组必须是先按照顺序排列好才可以，每次取中间的数和目标数比较，目标数大于中间数则从右边查找，否则从左边开始继续二分。

$arr = [1,2,3,4,5,6,7,8,9];
$item = 1;
//$result =  search($arr, $item);
//echo $result;
function search($arr,$item)
{
    $length = count($arr);
    $start = 0;
    $end = $length - 1;
    $middle = floor(($start + $end)/2);  //将floor改为ceil
//    echo $middle.'<br>'.$end.'<br>';
    while($start < $end -1)
    {
        if($item === $arr[$middle])
        {
//            echo '111<br>';
            return $middle;
        }
        else if($item < $arr[$middle])
        {
            $end = $middle; //此处无须减1
            $middle = floor(($start + $end)/2);
//            echo '222<br>';
//            echo $middle.'<br>';
        }else if($item > $arr[$middle])
        {
            $start = $middle; //此处无须加一
            $middle = floor(($start + $end)/2);
//            echo '333<br>';
//            echo $middle.'<br>';
        }else{
//            echo '555<br>';
            return false;
        }
    }
    //边界判断
    if($item === $arr[0]) return 0;
    if($item === $arr[$length - 1]) return $length - 1;
    return  '未找到';

}



//////////////////////////////////快速排序////////////////////////////////////////////////////////////////////
//通过一趟排序将数据分层两部分，然后分别对这两部分进行排序，最后，将三者合并起来，递归实现

$arr = [1,2,3,5,10,8,7,6,9];
function quick_sort($arr)
{
    $n = count($arr);
    if($n < 1) return $arr;   //关键，不可或缺，否则$l_arr = quick_sort($l_arr);中报错没有下标0；
    $key = $arr[0];
    $r_arr = array();
    $l_arr = array();

    for($i = 1; $i < $n; $i++)
    {
        if($arr[$i] >= $key)
        {
            $r_arr[] = $arr[$i];
        }else{
            $l_arr[] = $arr[$i];
        }
    }
    $l_arr = quick_sort($l_arr);
    $r_arr = quick_sort($r_arr);
    return array_merge($l_arr,array($key),$r_arr);
}

$result = quick_sort($arr);
var_dump($result);




















